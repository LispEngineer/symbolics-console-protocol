// Copyright 2022 Douglas P. Fields, Jr. All Rights Reserved

//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module c5g_symdec(

  //////////// CLOCK //////////
	input logic         CLOCK_125_p,
	input logic         CLOCK_50_B5B,
	input logic         CLOCK_50_B6A,
	input logic         CLOCK_50_B7A,
	input logic         CLOCK_50_B8A,
  
	//////////// LED //////////
	output logic [7:0]  LEDG,
	output logic [9:0]  LEDR,
  
	//////////// KEY //////////
	input  logic        CPU_RESET_n,
	input  logic [3:0]  KEY,
  
	//////////// SW //////////
	input  logic [9:0]  SW,
  
	//////////// SEG7 //////////
	output logic [6:0]  HEX0,
	output logic [6:0]  HEX1,
  
	//////////// Uart to USB //////////
	input  logic        UART_RX,
	output logic        UART_TX,
  
	//////////// SRAM //////////
	output logic [17:0] SRAM_A,
	output logic        SRAM_CE_n,
	inout  wire  [15:0] SRAM_D,
	output logic        SRAM_LB_n,
	output logic        SRAM_OE_n,
	output logic        SRAM_UB_n,
	output logic        SRAM_WE_n,

	//////////// SDCARD //////////
	output logic        SD_CLK,
	inout  logic        SD_CMD,
	inout  wire  [3:0]	SD_DAT,
  
	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout  wire  [35:0] GPIO 
	// 22-35 are HEX2-3
	// 0,2 are dedicated clock inputs
	// 3-18 are Arduino I/O
	// 16, 18 are PLL clock outputs
  
);

//========================================================
// Digilent PmodPS485 has these logic-level pins, used UART style
// 1. ~RE Receive Enable (leave low or NC to get data, high for high impedance)
// 2. TxD
// 3. RxD
// 4. DE  Driver Enable (high to send data, else high impedance)
// And can accept 3.3 or 5V input

logic rs422_re_n; // Receive enable (negative)
logic rs422_txd;
logic rs422_rxd;
logic rs422_de;   // Driver enable (positive)

//=======================================================
//  REG/WIRE declarations

// Main signals throughout the board
logic clock;
logic reset;

// Reimplement HEX2-3 from GPIO
logic [6:0] HEX2, HEX3;

// 7 Segment outputs
logic [6:0] ss0, ss1, ss2, ss3;

// Decoded RS422 biphase data
logic rs422_received;
logic rs422_clk;
logic nrz_received;
logic nrz_framing_error;
logic nrz_glitch;
logic bip_counter_overflow;

// Debugging
logic framing_error_seen = '0;

// ======================================================
// DEFAULTS (remove if using these pins)

// Output pins
assign LEDG = '0;
assign LEDR[9:3] = '0;
assign UART_TX = '0;
assign {SRAM_A, SRAM_CE_n, SRAM_LB_n, SRAM_OE_n, SRAM_UB_n, SRAM_WE_n} = '0;
assign SD_CLK = '0;

// Bidi pins - set them to high impedance
assign SRAM_D = 'z;
assign {SD_CMD, SD_DAT} = 'z;
// Skip GPIO used for HEX2-3, Digilent PmodRS485, outputs of biphase decoder
assign GPIO[21:17] = 'z;
assign GPIO[11:5] = 'z;
assign GPIO[2:0] = 'z;

//=======================================================
//  Structural coding

// Pick our main clock and reset
assign clock = CLOCK_50_B5B;
assign reset = ~KEY[0];

// Our HEX2-3 overlap with GPIO;
assign GPIO[28:22] = HEX2;
assign GPIO[35:29] = HEX3;

// Terasic wires their 7 segment hex displays backwards, so a positive
// signal turns off the LED.
assign HEX0 = ~ss0;
assign HEX1 = ~ss1;
assign HEX2 = ~ss2;
assign HEX3 = ~ss3;

// Show data on hex 0-3
seven_segment hex0 (
  .num(4'hA),
  .hex(ss0)
);
seven_segment hex1 (
  .num(4'hB),
  .hex(ss1)
);
seven_segment hex2 (
  .num(4'hF),
  .hex(ss2)
);
seven_segment hex3 (
  .num(4'hD),
  .hex(ss3)
);

// Digilent PmodRS422
assign GPIO[4] = rs422_re_n;
assign rs422_rxd = GPIO[3];
// Nothing connected for the transmit/DE
assign rs422_re_n = '0; // Constantly be receive enabled
// This is connected to 5V right now

// Decode our received biphase RS422 data to UART-style
biphase_to_nrz bip2nrz (
	.clk(clock),
  .rst(reset),
  
  // .biphase_in_raw(rs422_rxd),
  .biphase_in_raw(~KEY[3]), // Debug

  .nrz_out(rs422_received),
  .clock_out(rs422_clk),
  .data_received(nrz_received),
  .framing_error(nrz_framing_error),
  .glitch_ignored(nrz_glitch),

  // Debugging outputs
  .counter_overflow(bip_counter_overflow)
);

// Output our received signals on GPIO for inspection
assign GPIO[12] = rs422_clk;
assign GPIO[13] = rs422_received;
assign GPIO[14] = nrz_received;
assign GPIO[15] = nrz_framing_error;
assign GPIO[16] = bip_counter_overflow; // nrz_glitch;

// Show stuff
assign LEDR[0] = reset;
assign LEDR[1] = framing_error_seen;
assign LEDR[2] = bip_counter_overflow;

// Did we see a framing error? If so, remember it
always_ff @(posedge clock) begin
  if (reset)
    framing_error_seen <= '0;
  else if (nrz_framing_error)
    framing_error_seen <= '1;
end


endmodule
